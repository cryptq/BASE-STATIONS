-- ==============================================================
-- File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2014.2
-- Copyright (C) 2014 Xilinx Inc. All rights reserved.
-- 
-- ==============================================================


library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;

entity sync_sdiv_41s_41s_41_44_div_u is
  port (
    clk: in std_logic;
    reset : in std_logic;
    ce : in std_logic;
    dividend: in std_logic_vector(39 downto 0);
    divisor: in std_logic_vector(39 downto 0);
    quot: out std_logic_vector(39 downto 0);
    sign_in: in std_logic_vector(1 downto 0);
    sign_out: out std_logic_vector(1 downto 0);
    remd: out std_logic_vector(39 downto 0));
end entity;

architecture rtl of sync_sdiv_41s_41s_41_44_div_u is
  type RAMtype0 is array (0 to 40) of std_logic_vector(39 downto 0);
  type RAMtype1 is array (0 to 40) of unsigned(39 downto 0);
  type RAMtype2 is array (0 to 40) of unsigned(40 downto 0);
  type RAMtype3 is array (0 to 41) of std_logic_vector(1 downto 0);

  signal divisor_tmp, dividend_tmp, quot_tmp : RAMtype0;
  signal remd_tmp, comb_tmp : RAMtype1;
  signal cal_tmp : RAMtype2;
  signal sign_tmp : RAMtype3;
  signal dividend0 : std_logic_vector(39 downto 0);
  signal divisor0 : std_logic_vector(39 downto 0);
  signal sign0 : std_logic_vector(1 downto 0);
begin

  run: for i in 0 to 39 generate
    comb_tmp(i) <= remd_tmp(i)(38 downto 0) & dividend_tmp(i)(39);
    cal_tmp(i) <= ('0' & comb_tmp(i)) - unsigned('0' & divisor_tmp(i));
  end generate;

  quot <= quot_tmp(40);
  remd <= std_logic_vector(remd_tmp(40));
  sign_out <= sign_tmp(40);

  tran0 : process (clk)
  begin
    if (clk'event and clk='1') then
      if (ce = '1') then
        divisor0 <= divisor;
        dividend0 <= dividend;
        sign0 <= sign_in;
      end if;
    end if;
  end process;

  divisor_tran : process (clk, ce)
  begin
    if (clk'event and clk='1') then
      if (ce = '1') then
        divisor_tmp(0) <= divisor0;
        for i in 0 to 39 loop
          divisor_tmp(i+1) <= divisor_tmp(i);
        end loop;
      end if;
    end if;
  end process;

  dividend_tran : process (clk,ce)
  begin
    if (clk'event and clk='1') then
      if (ce = '1') then
        dividend_tmp(0) <= dividend0;
        for i in 0 to 39 loop
          dividend_tmp(i+1) <= dividend_tmp(i)(38 downto 0) & '0';
        end loop;
      end if;
    end if;
  end process;

  remain_trans :  process (clk)
  begin
    if (clk'event and clk='1') then
      if (ce = '1') then
        remd_tmp(0) <= (others => '0');
        for i in 0 to 39 loop
          if (cal_tmp(i)(40)='0') then
            remd_tmp(i+1) <= cal_tmp(i)(39 downto 0);
          else
            remd_tmp(i+1) <= comb_tmp(i);
          end if;
        end loop;
      end if;
    end if;
  end process;

  ret_trans : process (clk)
  begin
    if (clk'event and clk='1') then
      if (ce = '1') then
        for i in 0 to 39 loop
          quot_tmp(i+1) <= quot_tmp(i)(38 downto 0) & not cal_tmp(i)(40);
        end loop;
      end if;
    end if;
  end process;

  sign_trans : process (clk)
  begin
    if (clk'event and clk='1') then
      if (ce = '1') then
        sign_tmp(0) <= sign0;
        for i in 0 to 39 loop
          sign_tmp(i+1) <= sign_tmp(i);
        end loop;
      end if;
    end if;
  end process;

end architecture;

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;

entity sync_sdiv_41s_41s_41_44_div is
  port (
    clk: in std_logic;
    reset : in std_logic;
    ce : in std_logic;
    dividend: in std_logic_vector(40 downto 0);
    divisor: in std_logic_vector(40 downto 0);
    quot: out std_logic_vector(40 downto 0);
    remd: out std_logic_vector(40 downto 0));
end entity;

architecture rtl of sync_sdiv_41s_41s_41_44_div is
  component sync_sdiv_41s_41s_41_44_div_u is
    port (
      reset : in std_logic;
      clk : in std_logic;
      ce : in std_logic;
      dividend: in std_logic_vector(39 downto 0);
      divisor: in std_logic_vector(39 downto 0);
      quot: out std_logic_vector(39 downto 0);
      sign_in: in std_logic_vector(1 downto 0);
      sign_out: out std_logic_vector(1 downto 0);
      remd: out std_logic_vector(39 downto 0));
  end component;

  signal ce0 : std_logic;
  signal dividend0: std_logic_vector(40 downto 0);
  signal divisor0: std_logic_vector(40 downto 0);
  signal dividend_s, divisor_s : signed(40 downto 0);
  signal dividend_u,divisor_u : std_logic_vector(40 downto 0);
  signal quot_u, remd_u : std_logic_vector(39 downto 0);
  signal sign : std_logic_vector(1 downto 0);
  signal sign_in : std_logic_vector(1 downto 0);
begin
  dividend_s <= abs signed(dividend0);
  divisor_s <= abs signed(divisor0);
  dividend_u <= std_logic_vector(dividend_s);
  divisor_u <= std_logic_vector(divisor_s);
  sign_in <= (dividend0(40) xor divisor0(40)) & dividend0(40);

  sync_sdiv_41s_41s_41_44_div_u_0 : sync_sdiv_41s_41s_41_44_div_u
    port map
      (clk => clk,
       reset => reset,
       ce => ce0,
       dividend => dividend_u(39 downto 0),
       divisor => divisor_u(39 downto 0),
       quot => quot_u,
       sign_out => sign,
       sign_in => sign_in,
       remd => remd_u);

  tran0 : process (clk)
  begin
    if (clk'event and clk='1') then
      ce0 <= ce;
      divisor0 <= divisor;
      dividend0 <= dividend;
    end if;
  end process;

  result : process (sign(1), quot_u)
    variable quot_s : signed(40 downto 0);
  begin
    if (sign(1)) = '1' then 
      quot_s := -signed('0' & quot_u);
      quot <= std_logic_vector(quot_s);
    else
      quot <= '0' & quot_u;
    end if;
  end process;

  remain : process (sign(0), remd_u)
    variable remd_s : signed(40 downto 0);
  begin
    if sign(0) = '1' then
      remd_s := -signed('0' & remd_u);
      remd <= std_logic_vector(remd_s);
    else
      remd <= '0' & remd_u;
    end if;
  end process;
end architecture;

Library IEEE;
use IEEE.std_logic_1164.all;

entity sync_sdiv_41s_41s_41_44 is
    generic (
        ID : INTEGER;
        NUM_STAGE : INTEGER;
        din0_WIDTH : INTEGER;
        din1_WIDTH : INTEGER;
        dout_WIDTH : INTEGER);
    port (
        clk : IN STD_LOGIC;
        reset : IN STD_LOGIC;
        ce : IN STD_LOGIC;
        din0 : IN STD_LOGIC_VECTOR(din0_WIDTH - 1 DOWNTO 0);
        din1 : IN STD_LOGIC_VECTOR(din1_WIDTH - 1 DOWNTO 0);
        dout : OUT STD_LOGIC_VECTOR(dout_WIDTH - 1 DOWNTO 0));
end entity;

architecture arch of sync_sdiv_41s_41s_41_44 is
    component sync_sdiv_41s_41s_41_44_div is
        port (
            dividend : IN STD_LOGIC_VECTOR;
            divisor : IN STD_LOGIC_VECTOR;
            quot : OUT STD_LOGIC_VECTOR;
            remd : OUT STD_LOGIC_VECTOR;
            clk : IN STD_LOGIC;
            ce : IN STD_LOGIC;
            reset : IN STD_LOGIC);
    end component;

    signal sig_quot : STD_LOGIC_VECTOR(dout_WIDTH - 1 DOWNTO 0);
    signal sig_remd : STD_LOGIC_VECTOR(dout_WIDTH - 1 DOWNTO 0);



begin
    sync_sdiv_41s_41s_41_44_div_U :  component sync_sdiv_41s_41s_41_44_div
    port map (
        dividend => din0,
        divisor => din1,
        quot => dout,
        remd => sig_remd,
        clk => clk,
        ce => ce,
        reset => reset);

end architecture;


